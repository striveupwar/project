官方统一定义--没有

- 解决问题方法的效率，跟数据的组织方式有关
- 解决问题方法的效率，跟空间的利用效率有关
- 解决问题方法的效率，跟算法的巧妙程度有关

## 所以到底什么是数据结构？？？
1. 数据对象在计算机中的组织方式

逻辑结构
物理存储结构

2. 数据对象必定与一系列加在其上的操作相关联
3. 完成这些操作所用的方法就是算法

## 抽象数据类型（Abstract Data Type） 
1. 数据类型

数据对象集
数据集合相关联的操作集

2. 抽象：描述数据类型的方法不依赖于具体实现

与存放数据的机器无关
与数据存储的物理结构无关
与实现操作的算法和编程语言均无关

## 算法（Algorithm） 
1. 一个有限指令集
2. 接受一些输入（有些情况下不需要输入）
3. 产生输出
4. 一定在有限步骤之后终止
5. 每一条指令必须
1）有充分明确的目标，不可以有歧义
2）计算机能处理的范围之内
3）描述应不依赖于任何一种计算机语言以及具体的实现手段

### 空间复杂度S(n) —— 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。

### 时间复杂度T(n) —— 根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果

### 在分析一般算法的效率时，我们经常关注下面两种复杂度
最坏情况复杂度 Tworst( n ) 
平均复杂度 Tavg( n )

一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度

if-else 结构的复杂度取决于if的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大

## 什么是线性表
```
多项式表示问题的启示：
 1. 同一个问题可以有不同的表示（存储）方法
 2. 有一类共性问题：有序线性序列的组织和管理
```

- “线性表(Linear List)”：由同类型数据元素构成有序序列的线性结构

表中元素个数称为线性表的长度
线性表没有元素时，称为空表
表起始位置称表头，表结束位置称表尾

### 线性表的抽象数据类型描述
类型名称：线性表（List）

数据对象集：线性表是 n (≥0)个元素构成的有序序列( a1, a2, ...,an )

操作集：线性表L∈List，整数i表示位置，元素X∈ElementType，线性表基本操作主要有：

1. List MakeEmpty()：初始化一个空线性表L；
2. ElementType FindKth( int K, List L )：根据位序K，返回相应元素 ； 
3. int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置；
4. void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X；
5. void Delete( int i, List L )：删除指定位序i的元素；
6. int Length( List L )：返回线性表L的长度n。

```
线性表的顺序存储实现
- 利用数组的连续存储空间顺序存放线性表的各元素
```

```
线性表的链式存储实现
- 不要求逻辑上相邻的两个元素物理上也相邻；通过“链”建立起数据元素之间的逻辑关系。
• 插入、删除不需要移动数据元素，只需要修改“链”。
```

### 广义表(Generalized List)
广义表是线性表的推广
对于线性表而言， n个元素都是基本的单元素； 
广义表中，这些元素不仅可以是单元素也可以是另一个广义表。

### 多重链表
多重链表：链表中的节点可能同时隶属于多个链
多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域；
但包含两个指针域的链表并不一定是多重链表，比如在双向链表不是多重链表。 
多重链表有广泛的用途：基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储。

## 堆栈

中缀表达式：运算符号位于两个运算数之间。
后缀表达式：运算符号位于两个运算数之后。
```
需要有种存储方法，能顺序存储运算数，并在需要时“倒序”输出！
```
堆栈（Stack）：具有一定操作约束的线性表
    只在一端（栈顶，Top）做 插入、删除

插入数据：入栈（Push） 
删除数据：出栈（Pop） 
后入先出：Last In First Out（LIFO）

类型名称: 堆栈（Stack）
数据对象集：一个有0个或多个元素的有穷线性表。
操作集：长度为MaxSize的堆栈S  Stack，堆栈元素item  ElementType
1. Stack CreateStack( int MaxSize )： 生成空堆栈，其最大长度为MaxSize； 
2. int IsFull( Stack S, int MaxSize )：判断堆栈S是否已满；
3. void Push( Stack S, ElementType item )：将元素item压入堆栈；
4. int IsEmpty ( Stack S )：判断堆栈S是否为空；
5. ElementType Pop( Stack S )：删除并返回栈顶元素；

栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成。

栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。

堆栈的其他应用： 
函数调用及递归实现 深度优先搜索 回溯算法 。。。

## 什么是队列

队列(Queue)：具有一定操作约束的线性表
插入和删除操作：只能在一端插入，而在另一端删除。

数据插入：入队列（AddQ） 
数据删除：出队列（DeleteQ） 
先来先服务
先进先出：FIFO

类型名称：队列(Queue)
数据对象集：一个有0个或多个元素的有穷线性表。
操作集：长度为MaxSize的队列Q  Queue，队列元素item  ElementType
1. Queue CreatQueue( int MaxSize )：生成长度为MaxSize的空队列；
2. int IsFullQ( Queue Q, int MaxSize )：判断队列Q是否已满；
3. void AddQ( Queue Q, ElementType item )： 将数据元素item插入队列Q中；
4. int IsEmptyQ( Queue Q )： 判断队列Q是否为空；
5. ElementType DeleteQ( Queue Q )：将队头数据元素从队列中删除并返回。

```
队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。
```
```
队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行；
```

## 什么是树
客观世界中许多事物存在层次关系
人类社会家谱
社会组织结构
图书信息管理

分层次组织在管理上具有更高的效率!
数据管理的基本操作之一：查找

查找：根据某个给定关键字K ，从集合R中找出关键字与K相同的记录
静态查找：集合中记录是固定的 
    没有插入和删除操作，只有查找
    
动态查找：集合中记录是动态变化的 
    除查找，还可能发生插入和删除

顺序查找算法的时间复杂度为O(n)。

二叉树T：一个有穷的结点集合。
这个集合可以为空
若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。

特殊二叉树

斜二叉树(Skewed Binary Tree)
完美二叉树(Perfect Binary Tree) 满二叉树(Full Binary Tree）
完全二叉树(Complete Binary Tree)

二叉树几个重要性质
1. 一个二叉树第 i 层的最大结点数为：2的i-1次方，i ≥ 1。 
2. 对任何非空二叉树 T，若n0表示叶结点的个数、n2是度为2的非叶结点个数，那么两者满足关系n0= n2+1。
3. 深度为k的二叉树有最大结点总数为： 2的k次方-1，k ≥ 1。

二叉树的遍历
1. 先序遍历
2. 中序遍历
3. 后序遍历
同构

## 什么是二叉搜索树

二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树

二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：
1. 非空左子树的所有键值小于其根结点的键值。
2. 非空右子树的所有键值大于其根结点的键值。
3. 左、右子树都是二叉搜索树。

## 什么是平衡二叉树

平衡因子（Balance Factor，简称BF）: BF(T) = hL-hR，其中hL和hR分别为T的左、右子树的高度。

平衡二叉树（Balanced Binary Tree）（AVL树） 空树，或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T) |≤ 1

给定结点数为 n的AVL树的最大高度为O(log2n)

## 什么是堆

优先队列（Priority Queue）：特殊的“队列”，取出元素的顺序是 依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序

 堆的两个特性 
 结构性：用数组表示的完全二叉树； 
 有序性：任一结点的关键字是其子树所有结点的最大值(或最小值) 
    “最大堆(MaxHeap)”,也称“大顶堆”：最大值 
    “最小堆(MinHeap)”,也称“小顶堆” ：最小值 

## 哈夫曼树

带权路径长度(WPL)：设二叉树有n个叶子结点，每个叶子结点带 有权值 wk，从根结点到每个叶子结点的长度为 lk
最优二叉树或哈夫曼树: WPL最小的二叉树   

哈夫曼树的构造 ：每次把权值最小的两棵二叉树合并 

哈夫曼树的特点: 
没有度为1的结点； 
哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树； 
n个叶子结点的哈夫曼树共有2n-1个结点； 
对同一组权值{w1 ,w2 , …… , wn}，是否存在不同构的两 棵哈夫曼树呢？ 对一组权值{ 1, 2 , 3, 3 }，不同构的两棵哈夫曼树： 

## 集合的表示 

集合运算：交、并、补、差，判定一个元素是否属于某一集合 
并查集：集合并、查某元素属于什么集合 

可以用树结构表示集合，树的每个结点代表一个集合元素 

## 什么是“图”

表示“多对多”的关系

无向图 有向图

邻接矩阵
直观、简单、好理解
方便检查任意一对顶点间是否存在边
方便找任一顶点的所有“邻接点”（有边直接相连的顶点）
方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）
浪费空间 —— 存稀疏图（点很多而边很少）有大量无效元素
  对稠密图（特别是完全图）还是很合算的
浪费时间 —— 统计稀疏图中一共有多少条边

深度优先搜索(Depth First Search, DFS)
广度优先搜索(Breadth First Search, BFS)
回路：起点等于终点的路径
连通图：图中任意两顶点均连通

强连通：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的
强连通图：有向图中任意两顶点均强连通
强连通分量：有向图的极大强连通子图

